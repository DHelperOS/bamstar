# Supabase Edge Functions Îß§Ïπ≠ ÏãúÏä§ÌÖú ÏÑ§Í≥Ñ

## üéØ ÏÑ§Í≥Ñ Î™©Ìëú
- **ÏÑúÎ≤ÑÎ¶¨Ïä§**: Î≥ÑÎèÑ ÏÑúÎ≤Ñ ÏóÜÏù¥ Supabase Edge FunctionsÎßåÏúºÎ°ú Íµ¨ÌòÑ
- **ÌôïÏû• Í∞ÄÎä•**: ÏûêÎèô Ïä§ÏºÄÏùºÎßÅÏúºÎ°ú 10Îßå+ ÏÇ¨Ïö©Ïûê Ï≤òÎ¶¨
- **ÎπÑÏö© Ìö®Ïú®Ï†Å**: ÏÇ¨Ïö©Ìïú ÎßåÌÅºÎßå Í≥ºÍ∏à (Pay-per-use)
- **Ïã§ÏãúÍ∞Ñ Ï≤òÎ¶¨**: 50-200ms ÏùëÎãµ ÏãúÍ∞Ñ

## üèóÔ∏è ÏïÑÌÇ§ÌÖçÏ≤ò

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Flutter App    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  Edge Functions      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  PostgreSQL     ‚îÇ
‚îÇ                 ‚îÇ     ‚îÇ                      ‚îÇ     ‚îÇ                 ‚îÇ
‚îÇ - Member UI     ‚îÇ     ‚îÇ 1. match-calculator ‚îÇ     ‚îÇ - matching_*    ‚îÇ
‚îÇ - Place UI      ‚îÇ     ‚îÇ 2. match-finder     ‚îÇ     ‚îÇ   tables        ‚îÇ
‚îÇ                 ‚îÇ     ‚îÇ 3. match-scheduler  ‚îÇ     ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ 4. match-analytics  ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                  ‚îÇ
                                  ‚ñº
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                        ‚îÇ  Supabase Services   ‚îÇ
                        ‚îÇ - Realtime           ‚îÇ
                        ‚îÇ - Storage            ‚îÇ
                        ‚îÇ - Auth               ‚îÇ
                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üì¶ Edge Functions ÏÑ§Í≥Ñ

### 1. match-calculator (Îß§Ïπ≠ Ï†êÏàò Í≥ÑÏÇ∞)
```typescript
// supabase/functions/match-calculator/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

interface MatchRequest {
  memberId?: string
  placeId?: string
  batchSize?: number
}

interface MatchScore {
  memberId: string
  placeId: string
  totalScore: number
  details: {
    attributeScore: number
    preferenceScore: number
    locationScore: number
    payScore: number
    scheduleScore: number
  }
}

serve(async (req) => {
  try {
    const { memberId, placeId, batchSize = 100 } = await req.json() as MatchRequest
    
    // Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseKey)
    
    // Îß§Ïπ≠ ÎåÄÏÉÅ Ï∞æÍ∏∞
    let candidates = []
    
    if (memberId) {
      // MemberÎ•º ÏúÑÌïú Place ÌõÑÎ≥¥ Ï°∞Ìöå
      const { data: places } = await supabase
        .from('place_profiles')
        .select(`
          user_id,
          desired_experience_level,
          desired_pay_type,
          desired_pay_amount,
          desired_working_days,
          place_attributes_link!inner(attribute_id),
          place_preferences_link!inner(attribute_id),
          place_preferred_area_groups!inner(group_id)
        `)
        .eq('is_active', true)
        .eq('is_hiring', true)
        .limit(batchSize)
      
      candidates = places || []
    } else if (placeId) {
      // PlaceÎ•º ÏúÑÌïú Member ÌõÑÎ≥¥ Ï°∞Ìöå
      const { data: members } = await supabase
        .from('member_profiles')
        .select(`
          user_id,
          experience_level,
          desired_pay_type,
          desired_pay_amount,
          desired_working_days,
          member_attributes_link!inner(attribute_id),
          member_preferences_link!inner(attribute_id),
          member_preferred_area_groups!inner(group_id)
        `)
        .limit(batchSize)
      
      candidates = members || []
    }
    
    // Í∞Å ÌõÑÎ≥¥Ïóê ÎåÄÌï¥ Îß§Ïπ≠ Ï†êÏàò Í≥ÑÏÇ∞
    const scores: MatchScore[] = []
    
    for (const candidate of candidates) {
      const score = await calculateMatchScore(
        memberId || candidate.user_id,
        placeId || candidate.user_id,
        supabase
      )
      scores.push(score)
    }
    
    // Ï†êÏàò Í∏∞Ï§Ä Ï†ïÎ†¨
    scores.sort((a, b) => b.totalScore - a.totalScore)
    
    // Í≤∞Í≥ºÎ•º matching_scores ÌÖåÏù¥Î∏îÏóê Ï†ÄÏû• (Ï∫êÏã±)
    if (scores.length > 0) {
      await supabase
        .from('matching_scores')
        .upsert(
          scores.map(s => ({
            member_user_id: s.memberId,
            place_user_id: s.placeId,
            total_score: s.totalScore,
            attribute_match_score: s.details.attributeScore,
            preference_match_score: s.details.preferenceScore,
            location_match_score: s.details.locationScore,
            pay_match_score: s.details.payScore,
            schedule_match_score: s.details.scheduleScore,
            calculated_at: new Date().toISOString(),
            expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
          })),
          { onConflict: 'member_user_id,place_user_id' }
        )
    }
    
    return new Response(JSON.stringify({ 
      success: true, 
      count: scores.length,
      topMatches: scores.slice(0, 20)
    }), {
      headers: { 'Content-Type': 'application/json' },
    })
    
  } catch (error) {
    return new Response(JSON.stringify({ 
      error: error.message 
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    })
  }
})

// Îß§Ïπ≠ Ï†êÏàò Í≥ÑÏÇ∞ Î°úÏßÅ
async function calculateMatchScore(
  memberId: string,
  placeId: string,
  supabase: any
): Promise<MatchScore> {
  // 1. ÏÜçÏÑ± Îß§Ïπ≠ Ï†êÏàò
  const attributeScore = await calculateAttributeMatch(memberId, placeId, supabase)
  
  // 2. ÏÑ†Ìò∏ÎèÑ Îß§Ïπ≠ Ï†êÏàò
  const preferenceScore = await calculatePreferenceMatch(memberId, placeId, supabase)
  
  // 3. ÏúÑÏπò Îß§Ïπ≠ Ï†êÏàò
  const locationScore = await calculateLocationMatch(memberId, placeId, supabase)
  
  // 4. Í∏âÏó¨ Îß§Ïπ≠ Ï†êÏàò
  const payScore = await calculatePayMatch(memberId, placeId, supabase)
  
  // 5. ÏùºÏ†ï Îß§Ïπ≠ Ï†êÏàò
  const scheduleScore = await calculateScheduleMatch(memberId, placeId, supabase)
  
  // Í∞ÄÏ§ëÏπò Ï†ÅÏö©
  const weights = {
    attribute: 1.2,
    preference: 1.0,
    location: 1.5,
    pay: 2.0,
    schedule: 1.3
  }
  
  const totalScore = (
    attributeScore * weights.attribute +
    preferenceScore * weights.preference +
    locationScore * weights.location +
    payScore * weights.pay +
    scheduleScore * weights.schedule
  ) / Object.values(weights).reduce((a, b) => a + b, 0)
  
  return {
    memberId,
    placeId,
    totalScore,
    details: {
      attributeScore,
      preferenceScore,
      locationScore,
      payScore,
      scheduleScore
    }
  }
}

// ÏÑ∏Î∂Ä Ï†êÏàò Í≥ÑÏÇ∞ Ìï®ÏàòÎì§
async function calculateAttributeMatch(memberId: string, placeId: string, supabase: any): Promise<number> {
  // Member ÏÜçÏÑ±Í≥º PlaceÍ∞Ä ÏõêÌïòÎäî ÏÜçÏÑ± ÎπÑÍµê
  const { data: memberAttrs } = await supabase
    .from('member_attributes_link')
    .select('attribute_id')
    .eq('member_user_id', memberId)
  
  const { data: placePrefs } = await supabase
    .from('place_preferences_link')
    .select('attribute_id')
    .eq('place_user_id', placeId)
  
  if (!memberAttrs || !placePrefs || placePrefs.length === 0) return 0
  
  const memberAttrIds = new Set(memberAttrs.map(a => a.attribute_id))
  const matchCount = placePrefs.filter(p => memberAttrIds.has(p.attribute_id)).length
  
  return (matchCount / placePrefs.length) * 100
}

// ... ÎÇòÎ®∏ÏßÄ Í≥ÑÏÇ∞ Ìï®ÏàòÎì§ÎèÑ ÎèôÏùºÌïú Ìå®ÌÑ¥ÏúºÎ°ú Íµ¨ÌòÑ
```

### 2. match-finder (Ïã§ÏãúÍ∞Ñ Îß§Ïπ≠ Í≤ÄÏÉâ)
```typescript
// supabase/functions/match-finder/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

interface FindMatchRequest {
  userId: string
  userType: 'MEMBER' | 'PLACE'
  filters?: {
    minScore?: number
    maxDistance?: number
    payRange?: { min: number, max: number }
    experienceLevel?: string[]
  }
  limit?: number
  offset?: number
}

serve(async (req) => {
  try {
    const { userId, userType, filters = {}, limit = 20, offset = 0 } = await req.json() as FindMatchRequest
    
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseKey)
    
    // Ï∫êÏãúÎêú Îß§Ïπ≠ Ï†êÏàò Ï°∞Ìöå
    let query = supabase
      .from('matching_scores')
      .select(`
        *,
        ${userType === 'MEMBER' ? 'place_profiles!inner(*)' : 'member_profiles!inner(*)'}
      `)
    
    // ÌïÑÌÑ∞ Ï†ÅÏö©
    if (userType === 'MEMBER') {
      query = query.eq('member_user_id', userId)
    } else {
      query = query.eq('place_user_id', userId)
    }
    
    if (filters.minScore) {
      query = query.gte('total_score', filters.minScore)
    }
    
    // Í≤∞Í≥º Ï°∞Ìöå
    const { data: matches, error } = await query
      .order('total_score', { ascending: false })
      .range(offset, offset + limit - 1)
    
    if (error) throw error
    
    // ÎßåÎ£åÎêú Ï∫êÏãúÍ∞Ä ÏûàÏúºÎ©¥ Ïû¨Í≥ÑÏÇ∞ ÌÅêÏóê Ï∂îÍ∞Ä
    const expiredMatches = matches?.filter(m => 
      new Date(m.expires_at) < new Date()
    ) || []
    
    if (expiredMatches.length > 0) {
      // Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïû¨Í≥ÑÏÇ∞ Ìä∏Î¶¨Í±∞
      await triggerRecalculation(expiredMatches, supabase)
    }
    
    return new Response(JSON.stringify({
      success: true,
      matches: matches || [],
      hasMore: matches?.length === limit
    }), {
      headers: { 'Content-Type': 'application/json' },
    })
    
  } catch (error) {
    return new Response(JSON.stringify({ 
      error: error.message 
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    })
  }
})

async function triggerRecalculation(matches: any[], supabase: any) {
  // matching_queueÏóê Ïû¨Í≥ÑÏÇ∞ ÏöîÏ≤≠ Ï∂îÍ∞Ä
  const queueItems = matches.map(m => ({
    user_id: m.member_user_id,
    user_type: 'MEMBER',
    action: 'PARTIAL_UPDATE',
    priority: 3
  }))
  
  await supabase
    .from('matching_queue')
    .insert(queueItems)
}
```

### 3. match-scheduler (Î∞∞Ïπò Ï≤òÎ¶¨ Ïä§ÏºÄÏ§ÑÎü¨)
```typescript
// supabase/functions/match-scheduler/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// CronÏúºÎ°ú Ï£ºÍ∏∞Ï†Å Ïã§Ìñâ (1ÏãúÍ∞ÑÎßàÎã§)
serve(async (req) => {
  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseKey)
    
    // 1. ÎßåÎ£åÎêú Îß§Ïπ≠ Ï†êÏàò Ï°∞Ìöå
    const { data: expiredScores } = await supabase
      .from('matching_scores')
      .select('member_user_id, place_user_id')
      .lt('expires_at', new Date().toISOString())
      .limit(1000)
    
    // 2. ÌÅêÏóê Ï∂îÍ∞Ä
    if (expiredScores && expiredScores.length > 0) {
      const queueItems = expiredScores.map(score => ({
        user_id: score.member_user_id,
        user_type: 'MEMBER',
        action: 'FULL_RECALC',
        priority: 5
      }))
      
      await supabase
        .from('matching_queue')
        .insert(queueItems)
    }
    
    // 3. ÌÅê Ï≤òÎ¶¨
    const { data: queuedItems } = await supabase
      .from('matching_queue')
      .select('*')
      .eq('status', 'PENDING')
      .order('priority', { ascending: false })
      .order('created_at')
      .limit(100)
    
    // 4. Í∞Å ÏïÑÏù¥ÌÖú Ï≤òÎ¶¨
    for (const item of queuedItems || []) {
      await processQueueItem(item, supabase)
    }
    
    // 5. ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
    await updateMatchingStats(supabase)
    
    return new Response(JSON.stringify({
      success: true,
      processed: queuedItems?.length || 0,
      expired: expiredScores?.length || 0
    }), {
      headers: { 'Content-Type': 'application/json' },
    })
    
  } catch (error) {
    return new Response(JSON.stringify({ 
      error: error.message 
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    })
  }
})

async function processQueueItem(item: any, supabase: any) {
  try {
    // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    await supabase
      .from('matching_queue')
      .update({ status: 'PROCESSING' })
      .eq('id', item.id)
    
    // match-calculator Ìò∏Ï∂ú
    const response = await fetch(`${Deno.env.get('SUPABASE_URL')}/functions/v1/match-calculator`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${Deno.env.get('SUPABASE_ANON_KEY')}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        [item.user_type.toLowerCase() + 'Id']: item.user_id,
        batchSize: 50
      })
    })
    
    if (response.ok) {
      await supabase
        .from('matching_queue')
        .update({ 
          status: 'COMPLETED',
          processed_at: new Date().toISOString()
        })
        .eq('id', item.id)
    } else {
      throw new Error('Calculation failed')
    }
    
  } catch (error) {
    await supabase
      .from('matching_queue')
      .update({ 
        status: 'FAILED',
        error_message: error.message
      })
      .eq('id', item.id)
  }
}

async function updateMatchingStats(supabase: any) {
  // Îß§Ïπ≠ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
  const { data: stats } = await supabase
    .rpc('calculate_matching_stats')
  
  console.log('Matching stats updated:', stats)
}
```

### 4. match-analytics (Î∂ÑÏÑù Î∞è Î¶¨Ìè¨ÌåÖ)
```typescript
// supabase/functions/match-analytics/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

interface AnalyticsRequest {
  type: 'USER' | 'SYSTEM' | 'ADMIN'
  userId?: string
  dateRange?: {
    start: string
    end: string
  }
}

serve(async (req) => {
  try {
    const { type, userId, dateRange } = await req.json() as AnalyticsRequest
    
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseKey)
    
    let analytics = {}
    
    switch (type) {
      case 'USER':
        analytics = await getUserAnalytics(userId!, supabase)
        break
      case 'SYSTEM':
        analytics = await getSystemAnalytics(dateRange, supabase)
        break
      case 'ADMIN':
        analytics = await getAdminAnalytics(supabase)
        break
    }
    
    return new Response(JSON.stringify({
      success: true,
      analytics
    }), {
      headers: { 'Content-Type': 'application/json' },
    })
    
  } catch (error) {
    return new Response(JSON.stringify({ 
      error: error.message 
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' },
    })
  }
})

async function getUserAnalytics(userId: string, supabase: any) {
  // ÏÇ¨Ïö©ÏûêÎ≥Ñ Îß§Ïπ≠ ÌÜµÍ≥Ñ
  const { data: matchingHistory } = await supabase
    .from('matching_history')
    .select('event_type, created_at')
    .or(`member_user_id.eq.${userId},place_user_id.eq.${userId}`)
    .order('created_at', { ascending: false })
    .limit(100)
  
  const { data: topMatches } = await supabase
    .from('matching_scores')
    .select('*')
    .or(`member_user_id.eq.${userId},place_user_id.eq.${userId}`)
    .order('total_score', { ascending: false })
    .limit(10)
  
  return {
    totalInteractions: matchingHistory?.length || 0,
    eventBreakdown: groupByEventType(matchingHistory),
    topMatches: topMatches || [],
    avgMatchScore: calculateAvgScore(topMatches)
  }
}

async function getSystemAnalytics(dateRange: any, supabase: any) {
  // ÏãúÏä§ÌÖú Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ
  const { data: dailyStats } = await supabase
    .from('matching_scores')
    .select('calculated_at, total_score')
    .gte('calculated_at', dateRange?.start || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
    .lte('calculated_at', dateRange?.end || new Date().toISOString())
  
  return {
    totalMatches: dailyStats?.length || 0,
    avgScore: calculateAvgScore(dailyStats),
    scoreDistribution: calculateDistribution(dailyStats)
  }
}

function groupByEventType(history: any[]) {
  return history?.reduce((acc, item) => {
    acc[item.event_type] = (acc[item.event_type] || 0) + 1
    return acc
  }, {}) || {}
}

function calculateAvgScore(matches: any[]) {
  if (!matches || matches.length === 0) return 0
  const sum = matches.reduce((acc, m) => acc + m.total_score, 0)
  return Math.round(sum / matches.length * 100) / 100
}

function calculateDistribution(matches: any[]) {
  if (!matches) return {}
  return {
    '0-20': matches.filter(m => m.total_score < 20).length,
    '20-40': matches.filter(m => m.total_score >= 20 && m.total_score < 40).length,
    '40-60': matches.filter(m => m.total_score >= 40 && m.total_score < 60).length,
    '60-80': matches.filter(m => m.total_score >= 60 && m.total_score < 80).length,
    '80-100': matches.filter(m => m.total_score >= 80).length
  }
}
```

## üìã Î∞∞Ìè¨ Î∞è ÏÑ§Ï†ï

### 1. Edge Functions Î∞∞Ìè¨
```bash
# Í∞Å Ìï®Ïàò Î∞∞Ìè¨
supabase functions deploy match-calculator
supabase functions deploy match-finder
supabase functions deploy match-scheduler
supabase functions deploy match-analytics

# ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï
supabase secrets set MATCHING_BATCH_SIZE=100
supabase secrets set MATCHING_CACHE_TTL=604800  # 7 days in seconds
```

### 2. Cron ÏûëÏóÖ ÏÑ§Ï†ï
```sql
-- pg_cron ÌôïÏû• ÌôúÏÑ±Ìôî
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Îß§ÏãúÍ∞Ñ Ïä§ÏºÄÏ§ÑÎü¨ Ïã§Ìñâ
SELECT cron.schedule(
  'match-scheduler',
  '0 * * * *',  -- Îß§ÏãúÍ∞Ñ Ï†ïÍ∞Å
  $$
  SELECT net.http_post(
    url := 'https://tflvicpgyycvhttctcek.supabase.co/functions/v1/match-scheduler',
    headers := jsonb_build_object(
      'Authorization', 'Bearer ' || current_setting('app.supabase_anon_key'),
      'Content-Type', 'application/json'
    ),
    body := jsonb_build_object('trigger', 'cron')
  );
  $$
);

-- Îß§Ïùº ÏûêÏ†ï ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
SELECT cron.schedule(
  'match-analytics-daily',
  '0 0 * * *',  -- Îß§Ïùº ÏûêÏ†ï
  $$
  SELECT net.http_post(
    url := 'https://tflvicpgyycvhttctcek.supabase.co/functions/v1/match-analytics',
    headers := jsonb_build_object(
      'Authorization', 'Bearer ' || current_setting('app.supabase_anon_key'),
      'Content-Type', 'application/json'
    ),
    body := jsonb_build_object('type', 'SYSTEM')
  );
  $$
);
```

### 3. RLS Ï†ïÏ±Ö ÏÑ§Ï†ï
```sql
-- Edge Functions Ï†ÑÏö© ÏÑúÎπÑÏä§ Ïó≠Ìï† ÏÉùÏÑ±
CREATE ROLE edge_functions_role;

-- matching_scores ÌÖåÏù¥Î∏î Ï†ëÍ∑º Í∂åÌïú
GRANT SELECT, INSERT, UPDATE ON matching_scores TO edge_functions_role;
GRANT SELECT ON member_profiles TO edge_functions_role;
GRANT SELECT ON place_profiles TO edge_functions_role;
GRANT SELECT ON attributes TO edge_functions_role;

-- RLS Ï†ïÏ±Ö
CREATE POLICY "Edge functions can manage matching scores" 
ON matching_scores
FOR ALL 
USING (auth.role() = 'service_role');
```

## üéØ Flutter ÌÜµÌï©

### MatchingService ÏóÖÎç∞Ïù¥Ìä∏
```dart
class EdgeFunctionMatchingService {
  final SupabaseClient _supabase;
  
  EdgeFunctionMatchingService(this._supabase);
  
  // Îß§Ïπ≠ Í≤ÄÏÉâ
  Future<List<Match>> findMatches({
    required String userId,
    required UserType userType,
    Map<String, dynamic>? filters,
    int limit = 20,
  }) async {
    final response = await _supabase.functions.invoke(
      'match-finder',
      body: {
        'userId': userId,
        'userType': userType.name.toUpperCase(),
        'filters': filters,
        'limit': limit,
      },
    );
    
    if (response.error != null) {
      throw response.error!;
    }
    
    final matches = (response.data['matches'] as List)
      .map((m) => Match.fromJson(m))
      .toList();
    
    return matches;
  }
  
  // Îß§Ïπ≠ Ï†êÏàò Ïû¨Í≥ÑÏÇ∞ ÏöîÏ≤≠
  Future<void> recalculateMatches({
    required String userId,
    required UserType userType,
  }) async {
    final response = await _supabase.functions.invoke(
      'match-calculator',
      body: {
        '${userType.name.toLowerCase()}Id': userId,
        'batchSize': 100,
      },
    );
    
    if (response.error != null) {
      throw response.error!;
    }
  }
  
  // Îß§Ïπ≠ Î∂ÑÏÑù Ï°∞Ìöå
  Future<MatchingAnalytics> getAnalytics({
    required String userId,
  }) async {
    final response = await _supabase.functions.invoke(
      'match-analytics',
      body: {
        'type': 'USER',
        'userId': userId,
      },
    );
    
    if (response.error != null) {
      throw response.error!;
    }
    
    return MatchingAnalytics.fromJson(response.data['analytics']);
  }
  
  // Ïã§ÏãúÍ∞Ñ Îß§Ïπ≠ ÏóÖÎç∞Ïù¥Ìä∏ Íµ¨ÎèÖ
  Stream<List<Match>> subscribeToMatches({
    required String userId,
    required UserType userType,
  }) {
    final channel = _supabase
      .channel('matching_scores_changes')
      .on(
        RealtimeListenTypes.postgresChanges,
        ChannelFilter(
          event: '*',
          schema: 'public',
          table: 'matching_scores',
          filter: userType == UserType.member
            ? 'member_user_id=eq.$userId'
            : 'place_user_id=eq.$userId',
        ),
        (payload, [ref]) async {
          // Î≥ÄÍ≤ΩÏÇ¨Ìï≠ Î∞úÏÉù Ïãú Ïû¨Ï°∞Ìöå
          await findMatches(
            userId: userId,
            userType: userType,
          );
        },
      )
      .subscribe();
    
    // Stream Î∞òÌôò
    return _matchesController.stream;
  }
}
```

## üìä ÏÑ±Îä• Î∞è ÎπÑÏö© Î∂ÑÏÑù

### ÏÑ±Îä• ÏßÄÌëú
- **ÏùëÎãµ ÏãúÍ∞Ñ**: 50-200ms (Edge Function ÏΩúÎìú Ïä§ÌÉÄÌä∏ Ìè¨Ìï®)
- **Ï≤òÎ¶¨ Ïö©Îüâ**: Î∂ÑÎãπ 10,000+ Îß§Ïπ≠ Í≥ÑÏÇ∞
- **Ï∫êÏãú Ìö®Ïú®**: 80%+ Ï∫êÏãú ÌûàÌä∏Ïú®
- **ÌôïÏû•ÏÑ±**: ÏûêÎèô Ïä§ÏºÄÏùºÎßÅ (Î¨¥Ï†úÌïú)

### ÎπÑÏö© ÏòàÏ∏° (Ïõî Í∏∞Ï§Ä)
```
ÏÇ¨Ïö©Ïûê: 10,000Î™Ö
ÏùºÏùº ÌôúÏÑ± ÏÇ¨Ïö©Ïûê: 3,000Î™Ö
Îß§Ïπ≠ ÏöîÏ≤≠/ÏÇ¨Ïö©Ïûê/Ïùº: 10Ìöå

Edge Function Ìò∏Ï∂ú:
- 3,000 √ó 10 √ó 30 = 900,000 Ìò∏Ï∂ú/Ïõî
- ÎπÑÏö©: $0.00002/Ìò∏Ï∂ú √ó 900,000 = $18/Ïõî

Database ÏÇ¨Ïö©:
- Storage: 10GB = $25/Ïõî
- Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°: 50GB = $10/Ïõî

Ï¥ù ÏòàÏÉÅ ÎπÑÏö©: ~$53/Ïõî
```

## üîê Î≥¥Ïïà Í≥†Î†§ÏÇ¨Ìï≠

1. **API ÌÇ§ Í¥ÄÎ¶¨**: ÌôòÍ≤Ω Î≥ÄÏàòÎ°ú Í¥ÄÎ¶¨
2. **Rate Limiting**: ÏÇ¨Ïö©ÏûêÎ≥Ñ Î∂ÑÎãπ ÏöîÏ≤≠ Ï†úÌïú
3. **Ïù∏Ï¶ù**: Supabase Auth ÌÜ†ÌÅ∞ Í≤ÄÏ¶ù
4. **Îç∞Ïù¥ÌÑ∞ Í≤©Î¶¨**: RLSÎ°ú ÏÇ¨Ïö©ÏûêÎ≥Ñ Îç∞Ïù¥ÌÑ∞ Ï†ëÍ∑º Ï†úÌïú

## üöÄ Ïû•Ï†ê

1. **ÏÑúÎ≤ÑÎ¶¨Ïä§**: Ïù∏ÌîÑÎùº Í¥ÄÎ¶¨ Î∂àÌïÑÏöî
2. **ÏûêÎèô Ïä§ÏºÄÏùºÎßÅ**: Ìä∏ÎûòÌîΩÏóê Îî∞Îùº ÏûêÎèô ÌôïÏû•
3. **ÎπÑÏö© Ìö®Ïú®Ï†Å**: ÏÇ¨Ïö©Ìïú ÎßåÌÅºÎßå Í≥ºÍ∏à
4. **ÌÜµÌï© Ïö©Ïù¥**: Supabase ÏÉùÌÉúÍ≥ÑÏôÄ ÏôÑÎ≤Ω ÌÜµÌï©
5. **Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏**: Realtime Íµ¨ÎèÖ ÏßÄÏõê

## üìù ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Í≥ÑÌöç

### Phase 1: Edge Functions Í∞úÎ∞ú (1Ï£º)
- 4Í∞ú ÌïµÏã¨ Ìï®Ïàò Í∞úÎ∞ú Î∞è ÌÖåÏä§Ìä∏
- Î°úÏª¨ ÌôòÍ≤ΩÏóêÏÑú Í≤ÄÏ¶ù

### Phase 2: Î∞∞Ìè¨ Î∞è ÏÑ§Ï†ï (3Ïùº)
- Production ÌôòÍ≤Ω Î∞∞Ìè¨
- Cron ÏûëÏóÖ ÏÑ§Ï†ï
- Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï

### Phase 3: Flutter ÌÜµÌï© (1Ï£º)
- EdgeFunctionMatchingService Íµ¨ÌòÑ
- UI Ïª¥Ìè¨ÎÑåÌä∏ Ïó∞Îèô
- ÌÖåÏä§Ìä∏ Î∞è ÏµúÏ†ÅÌôî